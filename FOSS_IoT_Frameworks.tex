\documentclass{article}
\usepackage[utf8]{inputenc}

\title{FOSS IoT Frameworks review}
\author{Benoit RENAULT}
\date{2017/08/10}

%% Margins
\usepackage[
    top=3cm,
    bottom=3cm,
    left=3cm,
    right=3cm
]{geometry}

\usepackage{natbib}
\usepackage{graphicx}
\usepackage{hyperref}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section*{Introduction}
\addcontentsline{toc}{section}{\protect\numberline{}Introduction}%

The context for this document is the need for an IoT middleware platform for building, managing, and integrating connected products for the \href{https://github.com/occiware/occiware-ozwillo}{OCCIware LinkedData Use Case}. As the OCCIware project is FOSS\footnote{Free or Open-Source Software}, the component \textbf{must} be open-source itself. Therefore, what you will find here is a short state of the art of such frameworks, and no consideration shall be given to proprietary solutions.

\medskip

\emph{Please note that, while the evaluation criteria themselves may be considered timeless, the analyses presented below only reflect the state of the different projects as of this document's last update date, written on the first page.}

\medskip

\textbf{If you spot a mistake or confusion within the document, please don't hesitate to either open a Github issue on \href{https://github.com/Xia0ben/FOSS_IoT_Frameworks}{the source repository} or directly fork it, modify your clone, and make a pull-request for the author to easily merge your modifications if deemed appropriate.}

\section*{License}
\addcontentsline{toc}{section}{\protect\numberline{}License}%

This work is distributed under the \href{https://creativecommons.org/licenses/by-sa/4.0/}{Creative Commons Attribution-ShareAlike 4.0 International License} (CC BY-SA 4.0). You may find the complete license \href{https://github.com/Xia0ben/FOSS_IoT_Frameworks/blob/master/LICENSE}{on the report's Github repository}.

\medskip

\textbf{Attribution should at least contain the author's name "Benoit RENAULT" and a link to the source repository: \url{https://github.com/Xia0ben/FOSS_IoT_Frameworks}.}

\medskip

While the license doesn't require it, the author, Benoit Renault, would be glad if you notified him in the case you wish to reuse this report in some other work, by contacting him through a Github issue on this repository.

\newpage

\section{Evaluation criteria}

Each of the criteria is presented below with at least one argument as to how it allows to measure a given characteristic. The criteria are also chosen so that each solution needs not be analyzed more than three hours. For qualitative criteria, a little argumentation will be given in the detailed analysis (noted with excellent/good/average/poor/non-existent).

Some of them have been inspired by \href{https://www.thingworx.com/wp-content/uploads/WP_oreilly-media_evaluating-and-choosing-an-iot-platform_978-1-491-95203-0_EN.pdf}{an O'Reilly report on IoT platforms}, and the security-oriented ones by \href{https://www.owasp.org/index.php/IoT_Framework_Assessment}{Craig SMITH's "IoT Framework Assessment" OWASP page}.

\subsection{General criteria}

Here are some general criteria that allow us to assess the quality of any FOSS project.

\paragraph{Project Health} Determines how "mature" the project is, and its potential to last on the long term.

\begin{itemize}
\item First Release Date: The older, the better, might clue a position of pionneer, or a certain stability.
\item Latest Release Date: The newer, the better, might clue that the project's release cycle is still active.
\item Latest Commit Date: The newer, the better, if the project's release cycle is slow, might clue that the project is still ongoing active development.
\item Number of main contributors: The higher, the better. If equal to one, exercise caution. Main contributors have proportional contributions to the code repository.
\item Open issues ratio: The lower, the better. Is equal to the number of open issues over the total number of issues. Might clue at a good responsivity to user input, be it for bugs or improvements.
\end{itemize}

\paragraph{Company backing} Partly shows how reliable the software can be: if there is a company ready to back it up and provide support to customers, and if there are other companies using the software, it might mean that it is trustworthy.

\begin{itemize}
\item Company Support: The better the company support is, the better the appreciation.
\item Company Adoption: The more the software is adopted by other actors, the better the appreciation.
\end{itemize}

\paragraph{Documentation} A well-documented project is a must.

\begin{itemize}
\item Currentness: The documentation must be up to date with the code. The more it respects this principle, the better the appreciation.
\item Adaptability: Documentation must be adapted to the different users. The more it respects this principle, the better the appreciation.
\end{itemize}

\paragraph{UI-UX} The software must provide appropriate tools at all levels, be it CLIs or Graphical UIs, depending on the context.

\begin{itemize}
\item Server Management UI: the more powerful and concise, the better the appreciation.
\item Sample applications: the more there are and the more complete, the better the appreciation.
\end{itemize}

\subsection{IoT-specific criteria}

Here are some general criteria that allow us to assess the quality of IoT projects in particular.

\paragraph{Security} A key characteristic for IoT systems. As we cannot conduct a security assessment ourselves, we will rather look for a commitment to security and whether audits have been made or not. Security must be ensured at all levels: connectivity, storage, update, authentication, appropriate management of devices...

\begin{itemize}
\item Statements: the more is explained on the security measures taken in the documentation, the better the appreciation. Clues at a concern and understanding of the IoT problematics.
\item Audits: the more positive reviews about the security are, the better the appreciation. Clues at a good applications of best security practices.
\end{itemize}

\paragraph{Connectivity/Flexibility} Is very important for IoT systems, because they are supposed to connect many elements that are all very different.

\begin{itemize}
\item Number of compatible hardware platforms: The higher, the better. Might clue to a shorter time-to-market.
\item Number of supported protocols: The higher, the better. Might clue at a will not to lock the user in the system.
\item Number of SDK implementations: The higher, the better. Might clue at an easier time for in-house developpers to incorporate the solution with their own prefered language.
\item Modularity: the more the components of the solution can easily be changed (for instance, the DB), the better the appreciation.
\end{itemize}

\paragraph{Scalability} As IoT systems tend to grow really fast, it is necessary that the application scales by design, and allows for many devices, all over the world, to connect to it, without failure.

\begin{itemize}
\item Third-Party scalability: IoT solutions are often a combination of many pre-existing FOSS projects. This criteria evaluates whether the 3rd-Party solutions chosen by the IoT platform are capable of scaling: the more they are, the better the appreciation.
\item Platform scalability: IoT solutions must also be scalable themselves by being capable of being distributed across different machines and still be able to talk to one another smoothly. This criteria evaluates whether the platform is capable of scaling: the more it id, the better the appreciation.
\end{itemize}

\subsection{Application-specific criteria}

Here are some specific criteria that are related to the peculiar needs of the OCCIware project.

\paragraph{Arduino/NodeMCU compatibility} Since it is the most popular platform for hardware experimentation, it is an important criteria that the service musts provide good support for it.

\begin{itemize}
\item Library: The more complete and recognized the library, the better the appreciation.
\item Boilerplate code: The smaller the boilerplate code, the better the appreciation.
\end{itemize}

\paragraph{Java} The framework must be based on Java for easy editing of the sources and better maintainability, since it is the main language of the author.

\begin{itemize}
\item Server percentage: The higher the quantity of Java code for the server, the better.
\end{itemize}

\newpage

\section{Detailed analysis}

\subsection{SiteWhere}

\paragraph{Project Health}

\begin{itemize}
\item First Release Date: The development started in 2010 as a closed source, asset tracking platform. The first open source release happened on \textbf{2014/03/06}. With 7 years of age, it can be assumed it is quite mature and stable.
\item Latest Release Date: \textbf{2017/06/19} - Still releases new versions as of today. The project has an irregular release cycle, "When it's ready"-Debian-like.
\item Latest Commit Date: \textbf{2017/06/20} - Work is still ongoing to deliver a new version.
\item Number of main contributors: \textbf{1} - It seems to be mainly a one-man project, which is a problem. Some other people have contributed little bits of code, but not to the extent the main contributor has.
\item Open issues ratio: \textbf{0.0534653465} - With 505 issues opened by many various actors (and not just the main contributor as milestones) since the project's arrival on Github, only 27 remain today, which is a very, very good. Excellent reactivity.
\end{itemize}

Good project health overall, though a shame that it seems to have only one main developer behind it.

\paragraph{Company backing}

\begin{itemize}
\item Company Support: \textbf{excellent} - the project is backed by a well-established company (seven years of existence), and they offer a separate enterprise version with more features. Support is available to companies through the possibility to buy block hours for assistance, and also to anyone using the community edition through a rather active Google Group instance.
\item Company Adoption: \textbf{good} - the corporate page of the project gives 2 comments by supposed customers, no success story using sitewhere was found but there were a few press articles talking about it like \href{https://opensourceforu.com/2017/07/sitewhere-open-platform-connected-devices/?utm_content=buffer4c828&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer}{this one}. It can however be infered that if the company has existed for 7 years, it means that they have found clients that appreciate their services.
\end{itemize}

Good company backing overall, though it's a shame they don't communicate a bit more about their customers.

\paragraph{Documentation}

\begin{itemize}
\item Currentness: \textbf{good} - From the short time spent in the documentation, it seems it has been updated to match the latest release (as its number is written on the documentation homepage), however, in the absence of dating on all pages, it makes it more difficult to say if everything has been updated or not : for that, you have to go to the \href{https://github.com/sitewhere/sitewhere-documentation/}{documentation Github Repository}, which turns out to show that the documentation is rather up to date, since the oldest modifications are three month old.
\item Adaptability: \textbf{excellent} - The documentation is well separated between user and developper use cases. Explanations are clear, with lots of screenshots and appropriate commands where needed. The README.md on the Github Repository is crystal clear. Different levels of documentation are provided, like architecture, technologies, usage, code structure, ...
\end{itemize}

Good documentation overall, does make you want to use the product.

\paragraph{UI-UX}

\begin{itemize}
\item Server Management UI: \textbf{good} - Powerful and well-documented web administration interface, though its design is a little bit old school.
\item Sample applications: \textbf{good} - There are a few example applications for ios, android and webapps but not so many examples for hardware.
\end{itemize}

The proposed UIs seem good overall, but it would take a deeper examination to fully conclude on their capacity.

\paragraph{Security} 

\begin{itemize}
\item Statements: \textbf{average} - There is no open commitment to a secure system, on none of their websites. No explanation of the security measures they have taken, except that they use the Spring Frameworks integrated capabilities (which is good). No mention about the cryptographic means they use either.
\item Audits: \textbf{non-existent} - No mention on the product website, neither found any through a quick search on the web.
\end{itemize}

There is no apparent concern about security on their websites, which is certainly not good. Furthermore, there is apparently an SSL configuration problem with their corporate website, which is not a good sign.

\paragraph{Connectivity/Flexibility}

\begin{itemize}
\item Number of compatible hardware platforms: \textbf{4} - Android, Arduino, Raspberry Pi, and Generic Java-capable board (Cf. \href{http://documentation.sitewhere.io/integration.html}{dedicated documentation page}). Portentially highly compatible with many other platforms, but since no detail is given, we may assume with some reserves that not so many have actually been tested.
\item Number of supported protocols: \textbf{8} - MQTT, AMQP, OpenWire, XMPP, HTTP REST requests, WebSocket, Hazelcast, Stomp (Cf. \href{http://documentation.sitewhere.io/userguide/tenant/device-communication.html}{dedicated documentation page}).
\item Number of SDK implementations: \textbf{2} - Android and IOS.
\item Modularity: \textbf{good} - Design built out of preexisting opensource components. DB apparently easily changeable between MongoDB and Apache HBase (Cf. \href{http://documentation.sitewhere.io/architecture.html}{dedicated documentation page})
\end{itemize}

Overall, many connectors available, though seem to be a little weak on the hardware side, and lack of a SDK for Desktop applications.

\paragraph{Scalability}

\begin{itemize}
\item Third-Party scalability: \textbf{good} - Sitewhere offers a choice between MongoDB, Apache HBase and InfluxDB, which are three highly scalable Data Storage Technologies.
\item Platform scalability: \textbf{poor} - It seems a Sitewhere instance has no way to communicate with another and allow load-balancing.
\end{itemize}

It seems that Sitewhere's scalability claim is only based off the capabilities of its 3rd-parties components.

\paragraph{Arduino/NodeMCU compatibility}

\begin{itemize}
\item Library: \textbf{good} - Quite a lot of work seems to have been put into arduino compatibility, and the library seems very complete (with several example sketches included). However, no particular documentation about the NodeMCU/ESP8266.
\item Boilerplate code: \textbf{good} - The event/publish/subscribe structure, while being very efficient, requires here quite a lot of boilerplate code just to send a little bit of data.
\end{itemize}

Quite good Arduino compatibility, but it would really be welcome to have some documentation on its usage with NodeMCU/ESP8266 specifically.

\paragraph{Java} 

\begin{itemize}
\item Server percentage: \textbf{81.8\%} - The server is mainly just plain Java. Exactly what we need.
\end{itemize}

\subsection{Kaa}

\paragraph{Project Health}

\begin{itemize}
\item First Release Date: \textbf{2014/06/30} - The Kaa Project seems to have been open-sourced from its very beginning.
\item Latest Release Date: \textbf{2016/10/28} - The latest release dates back to the previous year, and could have us think that the project's activity has significantly dropped. The project has an irregular release cycle, "When it's ready"-Debian-like.
\item Latest Commit Date: \textbf{2017/06/31} - Actually, it seems that the project is still very much active, and a \href{https://www.youtube.com/watch?v=PaRSwYIGMG4}{recently posted video} on Youtube shows that they plan to release the 1.0 version during this summer. They seem to have reoriented all of their efforts into documenting/testing the project for the upcoming release.
\item Number of main contributors: \textbf{10} - There is a reasonable number of main contributors, whose work is rather well-distributed along time. All in all, the project has received contributions from 57 different contributors, which shows a good interest from the IoT community.
\item Open issues ratio: \textbf{0.0173032153} - A very low ratio, almost equal to zero : over the course of the project, 15893 issues have been opened, and now only 275 remain. It certainly goes to show that they have a proactive behaviour toward bugs. It is to be noted that they don't use Github Issues, but \href{http://jira.kaaproject.org/projects/KAA/issues/}{their own Jira instance}.
\end{itemize}

Kaa has a very good project health overall, especially since it has reached a point where the team behind it can trustfully say that they are ready for the 1.0 release.

\paragraph{Company backing}

\begin{itemize}
\item Company Support: \textbf{good} - The company behind Kaa, \href{https://www.kaaiot.io/}{KaaIoT}, seems to be more committed to corporate rather than community support (\href{https://stackoverflow.com/questions/44330714/why-are-the-questions-about-kaa-basically-not-being-answered}{see this StackOverflow discussion}), especially with the upcoming release.
\item Company Adoption: \textbf{average} - Given that the company has existed for 3 years, has, acccording to its LinkedIn page, between 51 and 200 employees, and that \href{https://www.kaaiot.io/company/careers/}{they are still recruiting a lot}, we can assume they have definitely found clients to buy one of the many formulas they offer on their corporate website. However, no trace was found on who these clients are.
\end{itemize}

Kaa is supported by a rather big team, and after 3 years of continued existence, we may assume that its company backing is good.

\paragraph{Documentation}

\begin{itemize}
\item Currentness: \textbf{good} - It seems like they have well divided and updated the documentation for each version. Though, it has the same little problem as Sitewhere : you have to go to the \href{https://github.com/kaaproject/kaa/blob/master/doc/}{repository's documentation folder} to check the last edition dates since they are not displayed on the website's pages.
\item Adaptability: \textbf{excellent} - The documentation itself is very-well separated by role of the reader. You have everything: administrator, hardware programmer, contributor guides. Each of these offer detailed explanations, with plenty of screenshots and code snippets to help you get started.
\end{itemize}

The overall quality of the documentation is very good, and makes you feel you can easily start using the solution right away.

\paragraph{UI-UX}

\begin{itemize}
\item Server Management UI: \textbf{good} - From what can be seen in the documentation, the administration UI is simple but complete, with a not so modern look, but we can bet that will be heavily upgraded in version 1.0.
\item Sample applications: \textbf{excellent} - Kaa offers a plethora of \href{https://github.com/kaaproject/sample-apps}{sample apps} that will help you get started, be it with hardware integration or client (apps) integration.
\end{itemize}

The user experience is especially good thanks to the many sample applications, and the clearly displayed will the Kaa project has to be extremely compatible.

\paragraph{Security} 

\begin{itemize}
\item Statements: \textbf{excellent} - A clear concern for security has been expressed by the CTO of the company in a \href{https://www.kaaproject.org/lets-address-dark-side-iot-tackling-security-community/}{blog post} and is also mentioned in their \href{https://www.kaaproject.org/faq/}{FAQ} and \href{http://docs.kaaproject.org/display/KAA/Endpoint+registration#Endpointregistration-Registrationsecurity}{documentation}. According to these sources, data communication between the components is secured using with 2048bits-RSA encryption and 256bits-AES signing. Apparently, Kaa also ensures secure data storage by enforcing database-level encryption, as well as tenant-level encryption, which is very good practice. In the FAQ, it is also said that Kaa is fault-tolerant, since the data is automatically replicated across the nodes.
\item Audits: \textbf{non-existent} - No mention on the product website, neither found any through a quick search on the web.
\end{itemize}

A clear concern for security is expressed, and some of the measures taken in favor of it are clearly explained. However, no independent security audit of the solution has ever been executed.

\paragraph{Connectivity/Flexibility}

\paragraph{Note:} With the upcoming 1.0 version, connectivity and flexibility is apparently about to skyrocket, since according to the \href{https://www.kaaproject.org/apply-for-early-access-to-kaa-1-0-banana-beach/}{Early Access application page}, the platform will turn to a SDK-less, technology independent paradigm, with Out-of-the-box MQTT support.

\begin{itemize}
\item Number of compatible hardware platforms: \textbf{8} - Kaa provides 8 endpoint SDK for many popular hardware platforms : RaspberryPi, ESP8266, ...
\item Number of supported protocols: \textbf{1} - Devices must use Kaa's own protocol (described \href{https://github.com/kaaproject/kaa-rfcs/}{here}), based on MQTT/CoAP. For easy implementation, Kaa provides many endpoint SDK for the different platforms.
\item Number of SDK implementations: \textbf{5} - Kaa provides 5 endpoint SDK for all main OSes : Linux, Android, MacOS, Windows, and finally, a generic SDK written in Java.
\item Modularity: \textbf{excellent} - it is already possible to change some components of Kaa pretty easily, for example, MongoDB and Cassandra are both supported as NoSQL DBs, but it is claimed that for the 1.0 version "Every component of the platform can be customized or substituted with 3rd party software".
\end{itemize}

Kaa overall boasts a very good connectivity and flexibility, and it seems they will continue in this direction.

\paragraph{Scalability}

\begin{itemize}
\item Third-Party scalability: \textbf{excellent} - Kaa offers a choice between two NoSQL DBS, MongoDB and Cassandra, and two SQL DBS, MariaDB and PostgreSQL, which are highly scalable, and all its other components, like Spark, are made for scalability.
\item Platform scalability: \textbf{excellent} - Kaa has been thought as a cluster of server nodes, and uses Apache ZooKeeper to coordinate services. Kaa also includes load-balancing capabilities. (Cf. its \href{https://kaaproject.github.io/kaa/docs/v0.10.0/Architecture-overview/}{Architecture Overview})
\end{itemize}

Kaa seems to have been truly been built from the ground-up to be fully distributed.

\paragraph{Arduino/NodeMCU compatibility}

\begin{itemize}
\item Library: \textbf{good} - As said before, there is a dedicated SDK for the ESP8266, but not for the NodeMCU, neither Arduino.
\item Boilerplate code: \textbf{good} - There is quite a little boilerplate C code, but it is well-explained, and it shouldn't be really too hard to work with it.
\end{itemize}

Relatively good compatibility with the ESP8266, however, the support for Arduino or NodeMCU is lacking.

\paragraph{Java} 

\begin{itemize}
\item Server percentage: \textbf{69.9\%} - Mainly developped in Java (Netty+Spring), almost all of its third party services are written in Java too.
\end{itemize}

\subsection{Device Hive}

\paragraph{Project Health}

\begin{itemize}
\item First Release Date: \textbf{2013/09/19} - The first release fo the server software has been made in 2013, though, on the corporate website, the copyright indicates an existence starting in 2012. The project has undergone big changes at its beginning, switching from .NET to Java, according to \href{http://www.techrepublic.com/blog/tablets-in-the-enterprise/devicehive-an-open-source-m2m-development-platform/}{this article}.
\item Latest Release Date: \textbf{2017/08/04} - The last release is very recent, meaning it still actively supported. The project has an irregular release cycle, "When it's ready"-Debian-like.
\item Latest Commit Date: \textbf{2017/08/17} - As of the writing of this report, commits are made daily on the development branches: we can thus deduce that the project is still undergoing developments.
\item Number of main contributors: \textbf{5} - It seems that two of the original contributors of the project do not contribute anymore to the server: maybe they ended up managing it. Anyway, the code base seems rather shared among a few people, which is good. A total of 30 persons have contributed to the project, which means there is a mild interest from the FOSS IoT community.
\item Open issues ratio: \textbf{0.3434343434} - The project doesn't seem to use Github issues a lot: since its creation on Github, only 99 issues have been created and 34 are still open to this day.
\end{itemize}

The project seems in overall good health, and still growing.

\paragraph{Company backing}

\begin{itemize}
\item Company Support: \textbf{good} - DeviceHive is supported by \href{http://www.dataart.com/}{DataArt}, a company that has, according to \href{https://www.linkedin.com/company/dataart}{LinkedIn}, 1001 to 5000 employees. Community support seems rather weak, with only a \href{https://docs.devicehive.com/discuss}{helpdesk} that doesn't seem to have been of much use (only one message), and the sporadic use of Github issues doesn't clue at a very active community exchange. 
\item Company Adoption: \textbf{good} - DataArt has a \href{http://www.dataart.com/clients/select-clients}{huge list of clients}, and \href{http://www.dataart.com/about-dataart/industry-recognition}{received quite a few awards}, but most of this is not directly linked to DeviceHive, which seems to be only one of their many projects. On their \href{http://www.dataart.com/clients/success-stories}{success stories pages}, there is actually one company that mentions DeviceHive: \href{http://www.interdigital.com/solution/wotio}{Wot.io}.
\end{itemize}

Overall, DeviceHive has good company backing, though the community aspect of the project seems lacking.

\paragraph{Documentation}

\begin{itemize}
\item Currentness: \textbf{good} - There is a separate documentation for the older 2.0 and latest 3.3.0 versions, which tends to prove that the documentation is up to date, however, there are no easy means to check the last edition dates since it is not even on Github but on a proprietary service called \href{https://readme.io/}{ReadMe}.
\item Adaptability: \textbf{average} - There is no separation of roles in the documentation, but rather a collection of categories, which goes directly from the "Getting Started and tutorials" to "Specific technical information". There is no page adressing the global architecture.
\end{itemize}

\paragraph{UI-UX}

\begin{itemize}
\item Server Management UI: \textbf{good} - The server management has a beautiful design, and even comes with an integrated tutorial that easily lets you get started. However, it seems it has rather few capabilities (you can only manage three basic tables: networks, devices and JWT tokens, but there is nothing to configure the server graphically).
\item Sample applications: \textbf{average} - The only client interface provided is a web interface, based on \href{http://freeboard.io/}{FreeBoard}. Nothing for native development. As for sample apps, there is only one for RaspberryPi and one for ESP8266.
\end{itemize}

\paragraph{Security} 

\begin{itemize}
\item Statements: \textbf{poor} - No statements on security whatsoever. It is not even clearly documented what they use for authentication, encryption and signing. Nothing on the corporate website, nothing in the documentation, except an API for authentification which means there is something, but that's it.
\item Audits: \textbf{non-existent} - No mention on the product website, neither found any through a quick search on the web.
\end{itemize}

Security is not clearly a concern for the DeviceHive project, which is quite bothering for an IoT project.

\paragraph{Connectivity/Flexibility}

\begin{itemize}
\item Number of compatible hardware platforms: \textbf{2} - Only two platforms have been documented : RaspberryPi and ESP8266.
\item Number of supported protocols: \textbf{3} - REST API, WebSockets or MQTT. This is the minimum to potentially allow for any kind of device to connect, from OS-enabled ones, to barebone ones.
\item Number of SDK implementations: \textbf{2} - Python, Node/Javascript. It seems there were many more before (Go, Java,...), but they have now been deprecated.
\item Modularity: \textbf{average} - Though DeviceHive is built on top of popular third-party FOSS components (ElasticSearch, Apache Spark, Cassandra and Kafka), no choice is left as to what to use.
\end{itemize}

The connectivity and flexibility of DeviceHive seems in fact rather poor overall.

\paragraph{Scalability}

\begin{itemize}
\item Third-Party scalability: \textbf{excellent} - The scalability of the components named above (ElasticSearch, Apache Spark, Cassandra and Kafka) is very good, as they were all designed for this.
\item Platform scalability: \textbf{good} - DeviceHive uses a container based service oriented architecture approach, managed and orchestrated by Kubernetes. This takes advantage of the inherent capabilities of Docker, but it is not mentioned how the different DeviceHive instances might interact (as their is no Architecture overview in the documentation!).
\end{itemize}

The approach DeviceHive takes to scalability definitely is interesting, but also cruely lacks documentation.

\paragraph{Arduino/NodeMCU compatibility}

\begin{itemize}
\item Library: \textbf{average} - No Arduino nor NodeMCU libraries, but there is one for the ESP8266.
\item Boilerplate code: \textbf{good} - Minimal boilerplate code, since it is javascript.
\end{itemize}

There are some examples with the ESP8266, however they do not seem to cover much.

\paragraph{Java} 

\begin{itemize}
\item Server percentage: \textbf{97.2\%} - Almost everything is pure Java, which makes it potentially easily maintainable.
\end{itemize}

\subsection{Zetta JS}

\paragraph{Project Health}

\begin{itemize}
\item First Release Date: \textbf{2014/07/23} - The project has started on Github three years ago, which is more or less the same as most of the projects presented here.
\item Latest Release Date: \textbf{2017/07/07} - The latest release is little more than one month old : we can deduce of this that the project is still maintained.
\item Latest Commit Date: \textbf{2017/07/07} - No advancements have been made since the last release: maybe is it due to summer holidays.
\item Number of main contributors: \textbf{3} - Only three people are behind this project, and it seems that one of them as left the project at the end of 2016. The Github organization only belongs to one person, which is not necessarily a good thing.
\item Open issues ratio: \textbf{0.2565789474} - The project doesn't seem to use Github issues a lot: since its creation on Github, only 152 issues have been created and 39 are still open to this day.
\end{itemize}

Project health looks greenish overall. It might lack maintainers, which would explain the high open issues ratio.

\paragraph{Company backing}

\begin{itemize}
\item Company Support: \textbf{good} - ZettaJS is backed up by \href{https://apigee.com/}{APIGEE}, a company that creates API-driven applications, and that is been bought by Google in 2016. Actually they sell Apigee Link, a \href{https://apigee.com/about/press-release/apigee-launches-apigee-link-\%E2\%80\%9Capi-first\%E2\%80\%9D-internet-things-iot-product}{service that leverages Zetta}, adding enterprise support and cloud services. As for community support, there is a relatively active dedicated \href{https://groups.google.com/forum/#!forum/zetta-discuss}{Google Group}.
\item Company Adoption: \textbf{average} - APIGEE seems to have a lot of \href{https://apigee.com/api-management/#/customers}{big customers}, and quite a few \href{https://apigee.com/api-management/#/resources?sorting=DESC&contentType=customer_story}{success stories}. However, none of them seem directly related to Zetta.
\end{itemize}

Overall good company backing, though we have no clear and direct evidence of companies using Zetta.

\paragraph{Documentation}

\begin{itemize}
\item Currentness: \textbf{average} - Most of the wiki hasn't been updated since last year, thus we can infer that there may be a few elements that may differ with the current release.
\item Adaptability: \textbf{average} -  There is no separation of roles in the documentation, but rather a collection of categories, which goes directly from the "Getting Started and tutorials" to "Specific technical information". It definitely feels more like something oriented for tinkerers, rather than to the many different actors using an IoT platform.
\end{itemize}

Overall, the documentation doesn't look that good. Particularly, it uses the integrated Wiki function of Github, making it clearly dev-oriented, and ignoring all other actors.

\paragraph{UI-UX}

\begin{itemize}
\item Server Management UI: \textbf{average} - There is a UI but it seems only capable to list devices and access their APIs. No user management, no tenant management,...
\item Sample applications: \textbf{average} - There are a few \href{http://www.zettajs.org/projects/}{example projects} that are relatively well-documented.
\end{itemize}

In terms of UI-UX, ZettaJS seems lacking overall, since its focus is primarily in providing APIs.

\paragraph{Security} 

\begin{itemize}
\item Statements: \textbf{poor} - No statements about security except \href{https://github.com/zettajs/zetta/wiki/Overview#linking}{one short paragraph} in the documentation, that doesn't explain the security strategy at all.
\item Audits: \textbf{non-existent} - No mention on the product website, neither found any through a quick search on the web.
\end{itemize}

ZettaJS doesn't express much concerns about security, though it is a key element of IoT.

\paragraph{Connectivity/Flexibility}

\begin{itemize}
\item Number of compatible hardware platforms: \textbf{11} - This is hard number to estimate since Zetta rather use a generic concept of "Driver" for any kind of connection. From the \href{http://www.zettajs.org/modules/}{official driver list}, the following harware platforms have been spotted: Wemo, Sphero, Spark, BeagleBone, Pinoccio, Pebble, OpenXC, RaspberryPi, XiaoMi, Intel Edison, Google Glass.
\item Number of supported protocols: \textbf{1} - ZettaJS seems to only understand HTTP requests, though it claims it should be able to bridge other protocols to it, but we couldn't find any such example.
\item Number of SDK implementations: \textbf{1} - There is only a \href{https://github.com/zettajs/ZettaKit}{native SDK for IOS}.
\item Modularity: \textbf{good} - As everything is API, any component can conceptually be added/changed/removed easily.
\end{itemize}

The API-driven ideology seems to make connexion to the system very easy, but in fact, to this day, there seem to be no easy way to connect devices that don't run a linux kernel on them.

\paragraph{Scalability}

\begin{itemize}
\item Third-Party scalability: \textbf{poor} - LevelDB doesn't seem to have any sort of distribution capabilities.
\item Platform scalability: \textbf{poor} - As all the servers can easily communicate and exchange data through HTTP APIs, the project seems rather scalable, but there is no distributed data storage, or integrated load-balancing.
\end{itemize}

ZettaJS doesn't seem to integrate anything related to scalability.

\paragraph{Arduino/NodeMCU compatibility}

\begin{itemize}
\item Library: \textbf{poor} - No official library provided either for Arduino, NodeMCU or ESP8266, but there is a beginning of an implementation \href{https://github.com/zettajs/zetta-cli/tree/master/sample/basic-arduino}{here}.
\item Boilerplate code: \textbf{poor} - No official boilerplate code either, but there is a beginning of an implementation \href{https://github.com/zettajs/zetta-arduino}{here}.
\end{itemize}

No clear support of Arduino/NodeMCU in ZettaJS.

\paragraph{Java} 

\begin{itemize}
\item Server percentage: \textbf{0\%} - ZettaJS, is, as the name indicates, a full JS solution. No Java here.
\end{itemize}

\subsection{Parse}

\paragraph{Project Health}

\begin{itemize}
\item First Release Date: \textbf{2016/01/28} - The open-source version of the Parse platform has only been released one year ago, when the company behind it \href{http://blog.parse.com/announcements/moving-on/}{decided to close}.
\item Latest Release Date: \textbf{2017/07/03} - Even though the service closed in January 2017, the project still gets regular releases, the latest one having been made this summer.
\item Latest Commit Date: \textbf{2017/08/12} - The project is still undergoing changes, though the graphs are pretty clear on the fact that development is winding down.
\item Number of main contributors: \textbf{2} - Among the 159 contributors, the project is actually only developed by two persons. Although, there are 34 pull requests waiting for integration, and the many forks (over 3000 thousands) indicate that quite a few people are interested in keeping the project afloat.
\item Open issues ratio: \textbf{0.0742424242} - With 2640 issues created since the project's creatino, and only 196 remaining open today, it is an overall very good ratio, that shows that there is a real interaction with the community, and great reactivity.
\end{itemize}

It's hard to give an overall appreciation of the project's health. Indeed, one could be tempted to dismiss it as something that is just about to become abandonware, but the seemingly big community around it might keep it going properly.

\paragraph{Company backing}

\begin{itemize}
\item Company Support: \textbf{poor} - Since the company behind the project seems to have kind of dropped it, there is no longer company support. The community seems however relatively active on \href{https://stackoverflow.com/tags/parse.com}{StackOverflow} and \href{https://github.com/parse-community/parse-server/issues}{Github Issues}. An unofficial user community website has \href{http://parseopensource.github.io/}{also been created}.
\item Company Adoption: \textbf{good} - It seems quite a number of \href{https://www.quora.com/What-apps-are-built-on-Parse}{companies were using Parse} as a service before, and it is very likely that they simply migrated to the open source version for many of them. Especially most of the community projects around parse are maintained by \href{https://github.com/modernistik}{other companies}.
\end{itemize}

It seems that Parse is now mainly a community-governed project, meaning no easy way to get paid support. However, community support seems reactive.

\paragraph{Documentation}

\begin{itemize}
\item Currentness: \textbf{good} - It seems that the documentation has been well kept to date, with most pages having been edited in april/may 2017.
\item Adaptability: \textbf{good} - There is a separate wiki for \href{https://github.com/parse-community/parse-server/wiki}{developers} that might want to contribute and \href{http://docs.parseplatform.org/}{users}.
\end{itemize}

\paragraph{UI-UX}

\begin{itemize}
\item Server Management UI: \textbf{good} - The project includes a \href{https://github.com/parse-community/parse-dashboardweb}{dashboard}, which looks pretty neat, with a \href{http://blog.parse.com/announcements/introducing-the-parse-server-dashboard/}{Data browser and an API console}. However, it seems that some functionnalities from the ancient Dashboard of Parse.com have not been integrated in the new one, and won't ever be, like \href{http://docs.parseplatform.org/parse-server/guide/#compatibility-with-parsecom}{Analytics}, since they are no longer supported by Parse itself.
\item Sample applications: \textbf{good} - There is one \href{https://github.com/parse-community/parse-server-example}{repository} that has been kept up to date with an example application and some IoT-specific examples can be found in the \href{https://github.com/parse-community/Parse-SDK-Arduino}{Parse SDK for Arduino repository}, and some other examples can be found \href{http://teachmetomake.com/wordpress/arduinocloudparsetutorial}{on the web}.
\end{itemize}

The overall UI-UX is pretty fine, with many resources that are rather easy to find.

\paragraph{Security} 

\begin{itemize}
\item Statements: \textbf{good} - It seems that Parse is taking the subject of security rather seriously, are there are still \href{https://github.com/parse-community/parse-server/issues?utf8=\%E2\%9C\%93&q=is\%3Aissue\%20is\%3Aopen\%20security}{discussions on how to improve} it. Parse uses Application Keys for \href{http://docs.parseplatform.org/parse-server/guide/#using-parse-SDK-with-parse-server}{devicec authentication}, but other client-side keys can also be added. They also give \href{http://docs.parseplatform.org/rest/guide/#security}{very detailed instructions} on how to properly implement security in applications using the tools they provide. Finally, they recently forwarded a warning \href{http://blog.parseplatform.org/security/nodejs/update/notice/2017/07/20/nodejs-security-notice.html}{on the official blog} about a flaw in NodeJS.
\item Audits: \textbf{non-existent} - There are no traces of a proper audit of the Parse Platform, but some users did \href{https://groups.google.com/forum/#!topic/parse-developers/qjvKJYikHQ8}{voice concerns} about the Parse's security model, which have been adressed at the time.
\end{itemize}

Parse clearly voice their concern for security, however, there is no trace of an audit to confirm the good application of these principles.

\paragraph{Connectivity/Flexibility}

\begin{itemize}
\item Number of compatible hardware platforms: \textbf{3} - Arduino YÃºn, Unix-based, and RTOS platforms are supported by two projects: \href{https://github.com/parse-community/parse-embedded-SDK}{Parse Embedded SDK} and \href{https://github.com/parse-community/Parse-SDK-Arduino}{Parse SDK Arduino}.
\item Number of supported protocols: \textbf{1} - Everything is done through a REST HTTP API.
\item Number of SDK implementations: \textbf{7} - iOS, Android, Javascript, .NET + Xamarin, MacOS, Unity, PHP, there are many ways to easily inter-connect with Parse. There are also some experimental or community-initiated SDK implementations, like \href{https://github.com/parse-community/Parse-Swift}{Parse-Swift} or \href{https://github.com/modernistik/parse-stack}{a Ruby client}.
\item Modularity: \textbf{poor} - The project is tightly tied to NodeJS and MongoDB, and it take more than just a little work to get it working with other components.
\end{itemize}

The overall connectivity-flexiblity is good, but more client-focused than hardware-focused.

\paragraph{Scalability}

\begin{itemize}
\item Third-Party scalability: \textbf{average} - NodeJS and MongoDB are two technologies that are known for their capacity to scale.
\item Platform scalability: \textbf{poor} - It doesn't seem like any sort of inter-instance communication has been devised, nor is there any integrated load-balancing.
\end{itemize}

Parse looks like it could scale rather well if only it would integrate clear instructions on how to use several Parse servers.

\paragraph{Arduino/NodeMCU compatibility}

\begin{itemize}
\item Library: \textbf{average} - Efficient implementation, and easily imported. However it is only for the Arduino Yun, and not for the NodeMCU or ESP8266 and would require some adpatations.
\item Boilerplate code: \textbf{good} - Rather straight-forward boilerplate code, with detailed instructions both in the code and in the wiki.
\end{itemize}

There is an Arduino compatibility, however, it sadly only covers linux-enabled devices like the Yun.

\paragraph{Java} 

\begin{itemize}
\item Server percentage: \textbf{0\%} - This is a full JS solution, no Java here.
\end{itemize}

\subsection{Blynk}

\paragraph{Project Health}

\begin{itemize}
\item First Release Date: \textbf{2015/06/09} - The project started on January 16, 2015 with a successful Kickstarter campaign, and the project was quickly released under a free-software license in september.
\item Latest Release Date: \textbf{2017/08/07} - The latest release dates back to the month of this writing: we can deduce that the project is still very much active.
\item Latest Commit Date: \textbf{2017/08/15} - The latest commit is even more recent, thus we can expect other releases in the future.
\item Number of main contributors: \textbf{2} - Sadly, the project seems to be almost only maintained by two developpers, one on the server-side, the other one on the hardware-side. There are few other contributors other than them (merely a dozen for each of the repositories).
\item Open issues ratio: \textbf{0.0295420975} - Since the start of the project, 677 issues have been created, and only 20 remain today. This makes for a really low ratio, testifying a very good reactivity to community input.
\end{itemize}

The project seems very healthy overall, if we overlook the fact that only two developpers are  actively contributing to it.

\paragraph{Company backing}

\begin{itemize}
\item Company Support: \textbf{excellent} - The \href{http://www.blynk.io/plans/}{support plans} they provide seem very satisfying, and the company seems healthily running, since its business model of providing only the server and hardware libraries as free software, but leaving the application builder closed-sourced seem to have been a rewarding strategy. The main developers are very active on the forum, complementing the support the community already provides really well.
\item Company Adoption: \textbf{excellent} - It seems that quite a few companies have adopted Blynk, as their \href{http://www.blynk.io/#home}{homepage} shows: Blynk is part of the "Intel IoT Solutions Alliance", is associated with Sparkfun for Educational Hardware,...
\end{itemize}

Even though the team at Blynk doesn't seem to be very large, they actually look like they offer a very convincing company backing for their product.

\paragraph{Documentation}

\begin{itemize}
\item Currentness: \textbf{average} - It seems the documentation is not very actively maintained, since most of its pages have \\href{https://github.com/blynkkk/blynkkk.github.io}{not been updated for months} at least. Often, it must be completed by reading the forum like this \href{https://community.blynk.cc/t/solved-issues-installing-and-running-blynk-client-on-rpi/11196/12}{forum post testifies}. Though the community is very active, it doesn't contribute to the documentation directly, and the afore-mentioned answers do not end up being added to it.
\item Adaptability: \textbf{good} - Blynk is clearly geared toward the hacker/DIY market. Thus, their documentation reflects this, being more developer-oriented. However, the presentation sections are very understandable for anyone, and are well-separated from tutorials and technical matters. A for server administration, all the information can be found on the \href{https://github.com/blynkkk/blynk-server#requirements}{server's repository README.MD}.
\end{itemize}

Rather fine documentation, however, the lack of direct contributions from the community is a shame, since it is very active, and many posts on the forum would deserve to be properly transformed into documentation.

\paragraph{UI-UX}

\begin{itemize}
\item Server Management UI: \textbf{average} - The \href{https://github.com/blynkkk/blynk-server#administration-ui}{Administration UI} offers somewhat the same functionnalities as the other solutions, though not as complete as what you would have with Parse or Kaa. The design is simple and minimalist.
\item Sample applications: \textbf{good} - The provided Blynk app is excellent in terms of functionnalities, and this part would have deserved an "excellent" mention if and only if there also were less functionnal open-source client apps provided. 
\end{itemize}

Good UI-UX experience overall, especially considering the great phone app.

\paragraph{Security} 

\begin{itemize}
\item Statements: \textbf{average} - While the corporate website doesn't mention security much, the \href{http://docs.blynk.cc/#security}{documentation} actually provide a few details as of the security measures taken by the platform, including authentication and end-to-end encryption.
\item Audits: \textbf{non-existent} - No mention on the product website, neither found any through a quick search on the web.
\end{itemize}

While the project seems to take security in consideration, this is apparently not their main concern, as they sometimes suggest reducing it, which is certainly not a good idea, especially if the connected devices are actuators.

\paragraph{Connectivity/Flexibility}

\begin{itemize}
\item Number of compatible hardware platforms: \textbf{4OO+} - According to \href{https://github.com/blynkkk/blynkkk.github.io/blob/master/SupportedHardware.md}{this list}, The project is compatible with about just any hardware platform !
\item Number of supported protocols: \textbf{2} - Blynk only speaks the \href{https://github.com/blynkkk/blynk-server#blynk-protocol}{Blynk protocol} and HTTP, which are completely defined \href{https://github.com/blynkkk/blynk-library/blob/master/src/Blynk/BlynkProtocolDefs.h}{here for the custom protocol} and \href{http://docs.blynkapi.apiary.io/#reference/0/qr-for-project-cloning}{here for HTTP}. Potentially, this can be extended through a \href{https://github.com/tzapu/node-red-contrib-blynk-websockets}{bridge to Nodered}, which brings in support for other protocols like MQTT, or XMPP.
\item Number of SDK implementations: \textbf{2} - iOS and Android apps are the only two SDK available at the moment. No official web implementation, nor desktop at the moment. It is to be reminded that these client apps \textbf{are not open-source}, and trying to use Blynk without them might be kind of a pain.
\item Modularity: \textbf{poor} - To this date, there is no componentization of Blynk-Server: it is just one big standalone, and most of the data isn't actually stored in it, it actually acts more like a bridge between the sensors and the app. If we want to store the raw data, two possibilities are offered: PostgreSQL and .csv files, but no way to leverage this stored data seems to be provided at the moment.
\end{itemize}

Overall, the connectivity/flexibility advantage of Blynk is solely assured by its hardware compatibility. When it comes to SDK or modularity, this is definitely not the case.

\paragraph{Scalability}

\begin{itemize}
\item Third-Party scalability: \textbf{average} - PostgreSQL is definitely capable of scaling, however, since the app does not take advantage of it, its interest stays limited.
\item Platform scalability: \textbf{poor} - There is no apparent way to distribute data storage, or any integrated load-balancing between server instances.
\end{itemize}

The scalability of Blynk seems rather limited, at least for the local version. Since on the official website, they claim that their Blynk Cloud Server handles 21 Billion+ requests per month, they must have devised of a way to scale their server application, but it is unclear how.

\paragraph{Arduino/NodeMCU compatibility}

\begin{itemize}
\item Library: \textbf{excellent} - The \href{https://github.com/blynkkk/blynk-library}{provided library} is highly complete, with the highest degree of arduino-compatibility around here. There is also everything needed for the NodeMCU and ESP8266.
\item Boilerplate code: \textbf{excellent} - Minimalist and powerful, many examples are given for just about any platform: the library takes care of almost everything.
\end{itemize}

Blynk boasts the best hardware compatibility out there, and such an ease of integration is simply found in none of the other projects.

\paragraph{Java} 

\begin{itemize}
\item Server percentage: \textbf{96.9\%} - This is a fully java-driven server, the other traces of code are HTML and CSS, which do not quite count.
\end{itemize}

\subsection{Kapua}

\paragraph{Project Health}

\begin{itemize}
\item First Release Date: \textbf{2017/04/28} - The Kapua project is extremely recent, in comparison to the others that all more or less started in 2013/2014. It started in 2016 as part of the Eclipse IoT ecosystem, according to the date of the first commit.
\item Latest Release Date: \textbf{2017/08/11} - This date doesn't mean much since it is only the second release of the project, and that it is still in its early beginnings.
\item Latest Commit Date: \textbf{2017/08/21} - The project is currently under very heavy development. New commits are added every day.
\item Number of main contributors: \textbf{8} - The project is maintained by approximately 8 persons, which makes for a decent number of people.
\item Open issues ratio: \textbf{0.335243553} - The high ratio is easily explained by the novel character of the project. What is interesting however is that it is not just people that are working on the project who post issues, but there seem to be a few users already, too.
\end{itemize}

The project has just been born, and from what we can see, it is clearly going at a steady pace and growing rapidly.

\paragraph{Company backing}

\begin{itemize}
\item Company Support: \textbf{good} - Kapua is supported by three big names : RedHat, Eurotech and Bosch. Redhat, for one, is a very well-known figure of the FOSS world. Of course, the project is also sponsored by the Eclipse Foundation, giving it even more credibility. Support is apparently mainly provided through \href{https://github.com/eclipse/kapua/issues}{the project's Github issues}, and the staff seems quite reactive to such queries. The community is also active on a \href{https://www.eclipse.org/forums/index.php/f/340/}{forum} and a \href{https://dev.eclipse.org/mailman/listinfo/kapua-dev}{mailing-list}. Though, it doesn't look like they have an active dedicated support line like the many projects that were named before.
\item Company Adoption: \textbf{good} - It seems that the main goal of the companies behind Kapua (along with its sister projects Hono and Kura, is for it to be used internally for all of their IoT projects. Apart from these companies, at the moment, it doesn't seem there are external customers using Kura.
\end{itemize}

Kapua is backed-up by big names of the digital industry, which is reassuring for the future of the project.

\paragraph{Documentation}

\begin{itemize}
\item Currentness: \textbf{average} - Since the project is very recent, we can assume that the documentation cannot have gotten far behind. Actually, according to the repository, the latest documentation modifications date back one month. Features like the Server Management UI are not in the documentation, so we can guess that this documentation may be lacking. On another note, what is especially pleasing about this documentation is its very powerful and good-looking display allowed by \href{https://www.gitbook.com/}{GitBook}.
\item Adaptability: \textbf{average} - The \href{http://download.eclipse.org/kapua/docs/develop/user-manual/en/}{user guide} and \href{http://download.eclipse.org/kapua/docs/develop/developer-guide/en/}{developer guide} are well-separated. There is even a separate \href{https://www.eclipse.org/kapua/getting-started.php}{Getting Started page}. However, in the end, almost only the developer guide is truly interesting, since the user guide is very poor.
\end{itemize}

Overall, we can assume that the not-so-good documentation is the result of young age of the project.

\paragraph{UI-UX}

\begin{itemize}
\item Server Management UI: \textbf{average} - From the very little we can see on the \href{https://www.eclipse.org/kapua/getting-started.php}{Getting Started page}, it seems there is such a tool, though it seems it is just an old interface originally developed by Eurotech (see copyright 2001-2006 at the bottom of the screenshot), and it is not mentioned in the documentation.
\item Sample applications: \textbf{poor} - There seem to be a provided \href{http://download.eclipse.org/kapua/docs/develop/user-manual/en/simulator.html}{Kura simulator}, but by no means can this be considered a sample application, rather a development tool. There is also a mention of a "heater app" on the Getting Started page, but it is unclear as to where to find it, and what it does.
\end{itemize}

Expectedly, since the project is rather recent, its UI-UX is rather poor overall. However, since the project is still under heavy development, we ca only expect it to get better.

\paragraph{Security} 

\begin{itemize}
\item Statements: \textbf{average} - The only mentions of the security procedures the project has deployed are on the \href{http://download.eclipse.org/kapua/docs/develop/user-manual/en/jwt_security.html}{JWT Security documentation page}. This merely hints at the use of encryption, but no details as to how it is enforced is given. A good point is that, thanks to the fact it is an Eclipse project, a proper \href{https://github.com/eclipse/kapua/issues}{contact form for reporting security issues} is provided.
\item Audits: \textbf{non-existent} - No mention on the product website, neither found any through a quick search on the web.
\end{itemize}

\paragraph{Connectivity/Flexibility}

\begin{itemize}
\item Number of compatible hardware platforms: \textbf{1} - Linux-based and \href{https://www.eclipse.org/kura/}{Kura}-Enabled hardware seems to be the only kind of compatible hardware. This includes the well-known RaspberryPi or BeagleBones. 
\item Number of supported protocols: \textbf{1} - It seems that currently, Kapua is only supposed to connect to MQTT-Kura enabled devices. Actually, the framework seems highly coupled with this other project.
\item Number of SDK implementations: \textbf{0} - No SDK of any sort has been found. 
\item Modularity: \textbf{poor} - It seems that aside from being able to switch between two database systems, MariaDB or H2 SQL Server, the project is rather monolithic, and does seem easy to fiddle with.
\end{itemize}

In the end, it seems that Kapua is far from complete, and its overall adaptability is rather poor.

\paragraph{Scalability}

\begin{itemize}
\item Third-Party scalability: \textbf{average} - Apart from the databases, the docker images are appreciated, but that's it.
\item Platform scalability: \textbf{poor} - There doesn't seem to be any effort geared toward scalability (the key-word doesn't even appear on the project's corporate page), no load-balancing, no data/computation distribution,...
\end{itemize}

Kapua doesn't seem to particularly shine in terms of scalability.

\paragraph{Arduino/NodeMCU compatibility}

\begin{itemize}
\item Library: \textbf{non-existent} - There is no support for Arduino/NodeMCU/ESP8266 whatsoever.
\item Boilerplate code: \textbf{non-existent} - Thus no boilerplate code.
\end{itemize}

Kapua has no support for Arduino/NodeMCU/ESP8266 at all.

\paragraph{Java} 

\begin{itemize}
\item Server percentage: \textbf{91.8\%} - Thanks to its status as an Eclipse project, Kapua is almost fully written in Java.
\end{itemize}

\subsection{NodeRed}

\paragraph{Project Health}

\begin{itemize}
\item First Release Date: \textbf{2013/10/16} - The project, as most of the others that are compared here, was created around 2013/2014, which makes it one of the long-standing contestants.
\item Latest Release Date: \textbf{2017/07/23} - Since the first release, 54 other releases were made, the latest one dating back from one month before this review. On top of that, the release cycle is highly regular. We can therefore assume it is still an active project.
\item Latest Commit Date: \textbf{2017/08/21} - The work did certainly not stop at the last release, and another one is in the making, as the latest commits prove it.
\item Number of main contributors: \textbf{2} - The project's code base is mainly maintained by two persons, though 56 contributors in total have brought their little piece to it.
\item Open issues ratio: \textbf{0.1063829787} - Over the course of the projects, 940 issues were created, and 100 remain to this day. The ratio is rather good, but in the light of the age of the projects and its extensive use of issues, it seems that the team may require more help treating all the queries. 
\end{itemize}

The project is in rather good health, aside from the fact the two main developers seem like they could use some help.

\paragraph{Company backing}

\begin{itemize}
\item Company Support: \textbf{good} - Node-RED was originally developed as a side-project by two members of the IBMâs Emerging Technology Services team and is now a part of the JS Foundation, of which IBM is one of the founding members. It is unclear whether IBM still finances the project, but it is clear that its main two developpers do commit a lot of their time to the project, and when they are not available, the very strong community fills in the GAP for support. However, there seem to be no clear company support offer, like a direct line to the devs through email or phone.
\item Company Adoption: \textbf{good} - According to \href{https://nodered.org/blog/2016/10/17/js-foundation}{this blog post}, companies such as \href{https://fred.sensetecnic.com/}{SenseTecnic}, \href{https://flow.att.com/}{AT\&T} and \href{https://www.redconnect.io/}{Red Ant} provide Node-RED services. Even though the software still hasn't released a 1.0 version, it seems rather trusted and well-known in the IoT industry. It also seems they have a partnership with the RaspberryPi foundation, since Node-RED is now available by default on every new RaspberryPi device.
\end{itemize}

Even though the project's governance is \href{https://nodered.org/about/governance/}{clearly willed to be community-driven}, the company-backing doesn't look half-bad, with some big names trusting the project.

\paragraph{Documentation}

\begin{itemize}
\item Currentness: \textbf{good} - According to the \href{https://github.com/node-red/node-red.github.io/tree/master/docs}{Github repository of the website}, the documentation is actively maintained, the latest changes having been made only 5 days before the writing of this review, and the oldest only 6 months old.
\item Adaptability: \textbf{excellent} - The documentation is \textbf{very-well organised}. User and developer resources are clearly separated, all very complete and accessible.
\end{itemize}

The documentation looks excellent overall. Add to this the many resources that have been devised by third-parties, like the ones of \href{http://noderedguide.com/}{Sense Tecnic}, and you have no reason not to easily get started.

\paragraph{UI-UX}

\begin{itemize}
\item Server Management UI: \textbf{excellent} - Actually, one of the main forte of the project is clearly its embedded UI that enables dynamic \href{https://en.wikipedia.org/wiki/Flow-based_programming}{Flow-Programming}. Everything is done through simple boxes, "nodes", linked together to create new functionnality. This workflow feels just right for the IoT, which is actually just that: connecting boxes together.
\item Sample applications: \textbf{good} - Actually, since Node-Red can be run on Edge devices, it is in itself a sample application, and \href{http://developers.sensetecnic.com/article/tutorial-connecting-device-node-red-to-cloud-node-red/}{can be used with a cloud instance}. There is also a \href{https://github.com/node-red/node-red-dashboard}{provided web-based dashboard} with many widgets from which to choose and compose your own application. However, an example Android or iOS native app couldn't be found.
\end{itemize}

In terms of UI-UX, Node-RED clearly tops any of the other solutions.

\paragraph{Security} 

\begin{itemize}
\item Statements: \textbf{good} - Most of security measures taken  in Node-RED are described on a \href{https://nodered.org/docs/security}{dedicated documentation page}. Though it seems that by default, Node-RED is insecure, all the steps to properly secure it with authentication and encryption are described on this page. However it doesn't seem there is any kind of storage-encryption.
\item Audits: \textbf{poor} - While it seems to be the only project of the entire list that got a security audit, \href{http://www.isgroup.it/node.security/audit-node-red.html}{the one we found} is rather poor since automated. Actually, it does have the merit to detect some missing HTTP security features, but many of the detected "problems" are actually false alerts.
\end{itemize}

It seems that the people behind Node-RED do care about security, though there seems to be some room for improvement.

\paragraph{Connectivity/Flexibility}

\begin{itemize}
\item Number of compatible hardware platforms: \textbf{17+} - According to \href{https://github.com/node-red/node-red-nodes}{the list of nodes in this repository}, there are already 17 hardware platforms that benefit of a node, but since it doesn't even include the arduino one, we can safely assume there are many more that are reported in this list.
\item Number of supported protocols: \textbf{2} - It seems that Node-RED is essentially capable of HTTP and MQTT interactions (actually, \href{https://nodered.org/about/}{its roots come from this second protocol}).
\item Number of SDK implementations: \textbf{2} - Let's say that the Node-RED interface makes one since it can be used \href{https://nodered.org/docs/platforms/android}{on phones} as well. To that we can add the \href{https://github.com/node-red/node-red-dashboard}{provided web-based dashboard}.
\item Modularity: \textbf{excellent} - Thanks to its "node"-paradigm, Node-RED can easily integrate just about any component, already including three DBs (LevelDB, MySQL, SQLite) for example.
\end{itemize}

Simply put, Node-RED is a model of connectivity/flexibility/modularity.

\paragraph{Scalability}

\begin{itemize}
\item Third-Party scalability: \textbf{good} - The nodes that integrate third-party components offer a very good scalability by themselves.
\item Platform scalability: \textbf{good} - The platform does not include scalability elements (\href{https://nodered.org/blog/2017/07/17/roadmap-to-1-dot-0}{planned for version 0.20}) like load-balancing and the such. However, it seems it is already easy to make to NodeRED instances communicate together (see links in the UI-UX part).
\end{itemize}

\paragraph{Arduino/NodeMCU compatibility}

\begin{itemize}
\item Library: \textbf{good} - It doesn't seem like there is a specific node and official documentation for the NodeMCU or the ESP8266 like \href{https://nodered.org/docs/hardware/arduino}{there is for the Arduino}, but it seems that we can make do with some third-party tutorials using generic nodes like \href{https://www.hackster.io/itchopshop/nodemcu-with-azure-mqtt-and-node-red-ef1f94}{this one}, or \href{http://www.instructables.com/id/Tutorial-ESP8266-and-Node-RED-MQTT-GPIO-Mosquitto-/}{this one}.
\item Boilerplate code: \textbf{excellent} - Actually, since its all flow-programming, there is no boilerplate code, which is very much appreciated !
\end{itemize}

\paragraph{Java} 

\begin{itemize}
\item Server percentage: \textbf{0\%} - NodeRed is a full Javascript/NodeJS project.
\end{itemize}

\newpage

\section{Summarized analysis}

\newpage

\section*{Conclusion}
\addcontentsline{toc}{section}{\protect\numberline{}Conclusion}%

\end{document}
